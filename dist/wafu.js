/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wafu"] = factory();
	else
		root["wafu"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/wafu.js":
/*!*********************!*\
  !*** ./src/wafu.js ***!
  \*********************/
/***/ ((module) => {

eval("var wafu = {\n\n    // Week name\n\n    _weekNames: {\n        '0': '日',\n        '1': '月',\n        '2': '火',\n        '3': '水',\n        '4': '木',\n        '5': '金',\n        '6': '土'\n    },\n\n    weekNames(keyFlag = true) {\n\n        if(keyFlag) {\n\n            return wafu._weekNames;\n\n        }\n\n        return wafu.arrayValues(wafu._weekNames);\n\n    },\n\n    weekName(weekNo) {\n\n        if(typeof moment !== 'undefined' && weekNo instanceof moment) {\n\n            weekNo = weekNo.day();\n\n        }\n\n        return wafu.arrayGet(wafu._weekNames, weekNo.toString());\n\n    },\n\n    hasWeekName(weekNo) {\n\n        return (wafu.weekName(weekNo) !== '');\n\n    },\n\n    longWeekNames(keyFlag = true) {\n\n        let weekNames = wafu.weekNames();\n        let longWeekNames = {};\n\n        for(let key in weekNames) {\n\n            longWeekNames[key] = weekNames[key] +'曜日';\n\n        }\n\n        if(keyFlag) {\n\n            return longWeekNames;\n\n        }\n\n        return wafu.arrayValues(longWeekNames);\n\n    },\n\n    longWeekName(weekNo) {\n\n        if(typeof moment !== 'undefined' && weekNo instanceof moment) {\n\n            weekNo = weekNo.day();\n\n        }\n\n        return wafu.arrayGet(wafu.longWeekNames(), weekNo.toString());\n\n    },\n\n    // Months\n\n    _months: {\n        '1': '1月',\n        '2': '2月',\n        '3': '3月',\n        '4': '4月',\n        '5': '5月',\n        '6': '6月',\n        '7': '7月',\n        '8': '8月',\n        '9': '9月',\n        '10': '10月',\n        '11': '11月',\n        '12': '12月'\n    },\n\n    months(keyFlag = true) {\n\n        if(keyFlag) {\n\n            return wafu._months;\n\n        }\n\n        return wafu.arrayValues(wafu._months);\n\n    },\n\n    month(monthNo) {\n\n        if(typeof moment !== 'undefined' && monthNo instanceof moment) {\n\n            monthNo = monthNo.month() + 1;\n\n        }\n\n        return wafu.arrayGet(wafu._months, monthNo.toString());\n\n    },\n\n    hasMonth(monthNo) {\n\n        const month = wafu.month(monthNo);\n        return (month !== '');\n\n    },\n\n    // Old month\n\n\n    _oldMonths: {\n        '1': '睦月',\n        '2': '如月',\n        '3': '弥生',\n        '4': '卯月',\n        '5': '皐月',\n        '6': '水無月',\n        '7': '文月',\n        '8': '葉月',\n        '9': '長月',\n        '10': '神無月',\n        '11': '霜月',\n        '12': '師走'\n    },\n\n    oldMonths(keyFlag = true) {\n\n        if(keyFlag) {\n\n            return wafu._oldMonths;\n\n        }\n\n        return wafu.arrayValues(wafu._oldMonths);\n\n    },\n\n    oldMonth(monthNo) {\n\n        if(typeof moment !== 'undefined' && monthNo instanceof moment) {\n\n            monthNo = monthNo.month() + 1;\n\n        }\n\n        return wafu.arrayGet(wafu._oldMonths, monthNo.toString());\n\n    },\n\n    hasOldMonth(monthNo) {\n\n        const month = wafu.oldMonth(monthNo);\n        return (month !== '');\n\n    },\n\n    // Gender\n\n    _genders: [\n        {id: '1', text: '男性'},\n        {id: '2', text: '女性'},\n        {id: '0', text: 'その他'}\n    ],\n\n    genders(otherFlag = false) {\n\n        let genders = wafu._genders;\n\n        if(!otherFlag) {\n\n            return [\n                genders[0],\n                genders[1]\n            ];\n\n        }\n\n        return genders;\n\n    },\n\n    gender(genderId) {\n\n        for(let index in wafu._genders) {\n\n            let gender = wafu._genders[index];\n\n            if(gender.id.toString() === genderId.toString()) {\n\n                return gender.text;\n\n            }\n\n        }\n\n        return '';\n\n    },\n\n    hasGender(genderId) {\n\n        return (wafu.gender(genderId) !== '');\n\n    },\n\n\n    // Prefecture\n\n    _prefectures: {\n        '1': '北海道',\n        '2': '青森県',\n        '3': '岩手県',\n        '4': '宮城県',\n        '5': '秋田県',\n        '6': '山形県',\n        '7': '福島県',\n        '8': '茨城県',\n        '9': '栃木県',\n        '10': '群馬県',\n        '11': '埼玉県',\n        '12': '千葉県',\n        '13': '東京都',\n        '14': '神奈川県',\n        '15': '新潟県',\n        '16': '富山県',\n        '17': '石川県',\n        '18': '福井県',\n        '19': '山梨県',\n        '20': '長野県',\n        '21': '岐阜県',\n        '22': '静岡県',\n        '23': '愛知県',\n        '24': '三重県',\n        '25': '滋賀県',\n        '26': '京都府',\n        '27': '大阪府',\n        '28': '兵庫県',\n        '29': '奈良県',\n        '30': '和歌山県',\n        '31': '鳥取県',\n        '32': '島根県',\n        '33': '岡山県',\n        '34': '広島県',\n        '35': '山口県',\n        '36': '徳島県',\n        '37': '香川県',\n        '38': '愛媛県',\n        '39': '高知県',\n        '40': '福岡県',\n        '41': '佐賀県',\n        '42': '長崎県',\n        '43': '熊本県',\n        '44': '大分県',\n        '45': '宮崎県',\n        '46': '鹿児島県',\n        '47': '沖縄県'\n    },\n\n    prefectures(shortFlag = false) {\n\n        const prefectures = wafu._prefectures;\n\n        if(shortFlag) {\n\n            let shortPrefectures = {};\n\n            for(let id in prefectures) {\n\n                let prefecture = prefectures[id];\n                shortPrefectures[id] = wafu.getShortPrefecture(prefecture);\n\n            }\n\n            return shortPrefectures;\n\n        }\n\n        return prefectures;\n\n    },\n\n    prefecture(prefectureId, shortFlag = false) {\n\n        if(wafu._prefectures[prefectureId] !== undefined) {\n\n            let prefecture = wafu._prefectures[prefectureId];\n\n            if(shortFlag) {\n\n                return wafu.getShortPrefecture(prefecture);\n\n            }\n\n            return prefecture;\n\n        }\n\n        return '';\n\n    },\n\n    prefectureId(prefectureName) {\n\n        for(let id in wafu._prefectures) {\n\n            let prefecture = wafu._prefectures[id];\n            let shortPrefecture = wafu.getShortPrefecture(prefecture);\n\n            if(prefecture === prefectureName || shortPrefecture === prefectureName) {\n\n                return id;\n\n            }\n\n        }\n\n        return -1;\n\n    },\n\n    hasPrefecture(prefectureId) {\n\n        return (wafu.prefecture(prefectureId) !== '');\n\n    },\n\n\n    // Region\n\n    _regions: {\n        '1': '北海道',\n        '2': '東北',\n        '3': '関東',\n        '4': '中部',\n        '5': '関西',\n        '6': '中国',\n        '7': '四国',\n        '8': '九州'\n    },\n\n    _regionPrefectureIds: {\n        '1': [1],\n        '2': [2, 3, 4, 5, 6, 7],\n        '3': [8, 9, 10, 11, 12, 13, 14],\n        '4': [15, 16, 17, 18, 19, 20, 21, 22, 23],\n        '5': [24, 25, 26, 27, 28, 29, 30],\n        '6': [31, 32, 33, 34, 35],\n        '7': [36, 37, 38, 39],\n        '8': [40, 41, 42, 43, 44, 45, 46, 47]\n    },\n\n    regions() {\n\n        return wafu._regions;\n\n    },\n\n    regionPrefectureIds() {\n\n        return wafu._regionPrefectureIds;\n\n    },\n\n    region(regionId) {\n\n        return wafu.arrayGet(wafu._regions, regionId.toString());\n\n    },\n\n    regionId(regionName) {\n\n        for(let id in wafu._regions) {\n\n            let region = wafu._regions[id];\n\n            if(region === regionName) {\n\n                return id;\n\n            }\n\n        }\n\n        return -1;\n\n    },\n\n    hasRegion(regionId) {\n\n        return (wafu.region(regionId) !== '');\n\n    },\n\n\n    // Era\n\n    _eras: [\n        { year: 2018, name: '令和', initial: 'R', symbol: 'reiwa', maxYear: null, startDate: '2019-05-01' },\n        { year: 1988, name: '平成', initial: 'H', symbol: 'heisei', maxYear: 31, startDate: '1989-01-08' },\n        { year: 1925, name: '昭和', initial: 'S', symbol: 'showa', maxYear: 64, startDate: '1926-12-25' },\n        { year: 1911, name: '大正', initial: 'T', symbol: 'taisho', maxYear: 15, startDate: '1912-07-30' },\n        { year: 1867, name: '明治', initial: 'M', symbol: 'meiji', maxYear: 45, startDate: '1868-01-25' }\n    ],\n\n    era(time) {\n\n        const isStrict = (time instanceof moment);\n        const year = (isStrict === true) ? time.year() : parseInt(time);\n\n        for(let i in wafu._eras) {\n\n            i = parseInt(i);\n            let era = wafu._eras[i];\n            const baseYear = era.year;\n\n            if(year > baseYear) {\n\n                let eraYear = year - baseYear;\n\n                if(isStrict === true) {\n\n                    const startDt = moment(era.startDate);\n\n                    if(time < startDt) {\n\n                        try {\n\n                            era = wafu._eras[i + 1];\n                            eraYear = era.maxYear;\n\n                        } catch(e) {}\n\n                    }\n\n                }\n\n                const eraName = era.name;\n                const eraYearCorrected = (eraYear === 1) ? '元' : eraYear;\n                return {\n                    'name': eraName,\n                    'year': eraYear,\n                    'initial': era.initial,\n                    'symbol': era.symbol,\n                    'full': eraName + eraYearCorrected +'年'\n                };\n\n            }\n\n        }\n\n        return null;\n\n    },\n\n    eraYear(time) {\n\n        let era = wafu.era(time);\n        return era.full;\n\n    },\n\n    eraYears() {\n\n        let eraYears = {};\n\n        for(let i in wafu._eras) {\n\n            let era = wafu._eras[i];\n            eraYears[era.symbol] = era.name;\n\n        }\n\n        return eraYears;\n\n    },\n\n    eraYearOptions(symbol) {\n\n        const maxYears = wafu.maxEraYears();\n        let options = {};\n\n        if(maxYears[symbol] !== undefined) {\n\n            let maxYear = maxYears[symbol];\n\n            for(let i = 1 ; i <= maxYear ; i++) {\n\n                options[i] = (i === 1) ? '元年' : i +'年';\n\n            }\n\n        }\n\n        return options;\n\n    },\n\n    maxEraYears() {\n\n        const now = new Date();\n        const currentYear = now.getFullYear();\n        let maxYears = {};\n\n        for(let i in wafu._eras) {\n\n            let era = wafu._eras[i];\n            let maxYear = (era.maxYear > 0) ? era.maxYear : currentYear - era.year;\n            maxYears[era.symbol] = maxYear;\n\n        }\n\n        return maxYears;\n\n    },\n\n    eraNames() {\n\n        let eraNames = [];\n\n        for(let i in wafu._eras) {\n\n            let era = wafu._eras[i];\n            eraNames.push(era.name);\n\n        }\n\n        return eraNames;\n\n    },\n\n    eraInitials() {\n\n        let eraInitials = [];\n\n        for(let i in wafu._eras) {\n\n            let era = wafu._eras[i];\n            eraInitials.push(era.initial);\n\n        }\n\n        return eraInitials;\n\n    },\n\n    eraSymbols() {\n\n        let eraSymbols = [];\n\n        for(let i in wafu._eras) {\n\n            let era = wafu._eras[i];\n            eraSymbols.push(era.symbol);\n\n        }\n\n        return eraSymbols;\n\n    },\n\n    commonYear(eraYear) {\n\n        eraYear = wafu.singleByte(eraYear).replace('元年', '1年');\n        const eraNamePattern = wafu.eraNames().join('|');\n        const eraInitialPattern = wafu.eraInitials().join('|');\n        const pattern = new RegExp('('+ eraNamePattern +'|'+ eraInitialPattern +')([0-9]+)[年]?');\n        const matches = eraYear.match(pattern);\n\n        if(matches) {\n\n            const eraName = matches[1];\n            let year = parseInt(matches[2]);\n\n            if(eraName === '明治' || eraName === 'M') {\n\n                year += 1867;\n\n            } else if(eraName === '大正' || eraName === 'T') {\n\n                year += 1911;\n\n            } else if(eraName === '昭和' || eraName === 'S') {\n\n                year += 1925;\n\n            } else if(eraName === '平成' || eraName === 'H') {\n\n                year += 1988;\n\n            } else if(eraName === '令和' || eraName === 'R') {\n\n                year += 2018;\n\n            }\n\n            return year;\n\n        }\n\n        return -1;\n\n    },\n\n    // Date\n\n    date(format, dateTime) {\n\n        if(!(dateTime instanceof moment)) {\n\n            dateTime = moment(dateTime);\n\n        }\n\n        const pattern = new RegExp('\\{([YymndjGgHhiswaEeFf])\\}', 'g');\n        format = format.replace(pattern, (match, symbol) => {\n\n            let replacedFormat = '';\n            let era = null;\n\n            switch(symbol) {\n\n                case 'Y':\n                    replacedFormat = 'YYYY年';\n                    break;\n                case 'y':\n                    replacedFormat = 'YY年';\n                    break;\n                case 'm':\n                    replacedFormat = 'MM月';\n                    break;\n                case 'n':\n                    replacedFormat = 'M月';\n                    break;\n                case 'd':\n                    replacedFormat = 'DD日';\n                    break;\n                case 'j':\n                    replacedFormat = 'D日';\n                    break;\n                case 'G':\n                    replacedFormat = 'H時';\n                    break;\n                case 'g':\n                    replacedFormat = 'H時';\n                    break;\n                case 'H':\n                    replacedFormat = 'HH時';\n                    break;\n                case 'h':\n                    replacedFormat = 'HH時';\n                    break;\n                case 'i':\n                    replacedFormat = 'mm分';\n                    break;\n                case 's':\n                    replacedFormat = 'ss秒';\n                    break;\n                case 'w':\n                    replacedFormat = wafu.weekName(dateTime.day());\n                    break;\n                case 'a':\n                    replacedFormat = (dateTime.format('a') === 'am') ? '午前' : '午後';\n                    break;\n                case 'E':\n                    era = wafu.era(dateTime);\n                    replacedFormat = era.full;\n                    break;\n                case 'e':\n                    era = wafu.era(dateTime);\n                    replacedFormat = '\\\\'+ era.initial + era.year;\n                    break;\n                case 'F':\n                    replacedFormat = 'YYYY年MM月DD日（'+ wafu.weekName(dateTime.day()) +'） HH時MM分';\n                    break;\n                case 'f':\n                    replacedFormat = 'YYYY年MM月DD日（'+ wafu.weekName(dateTime.day()) +'） HH:MM';\n                    break;\n\n            }\n\n            return replacedFormat;\n\n        });\n\n        return dateTime.format(format);\n\n    },\n\n    parseDate(date) {\n\n        date = wafu.singleByte(date).trim();\n        const weekNamePattern = wafu.arrayValues(wafu._weekNames).join('|');\n        const weekNamePatterns = [\n            '（('+ weekNamePattern +')）',\n            '\\\\(('+ weekNamePattern +'\\\\))'\n        ];\n\n        for(let i in weekNamePatterns) {\n\n            let weekNamePattern = new RegExp(weekNamePatterns[i]);\n            date = date.replace(weekNamePattern, '');\n\n        }\n\n        const eraNamePattern = wafu.eraNames().join('|');\n        const eraInitialPattern = wafu.eraInitials().join('|');\n        const eraPatterns = [\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日 ([\\\\d]+)時([\\\\d]+)分([\\\\d]+)秒',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日 ([\\\\d]+)時([\\\\d]+)分',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日 ([\\\\d]+)時',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日 ([\\\\d]+):([\\\\d]+):([\\\\d]+)',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日 ([\\\\d]+):([\\\\d]+)',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月([\\\\d]+)日',\n            '(('+ eraNamePattern +')[\\\\d]+年)([\\\\d]+)月',\n            '(('+ eraNamePattern +')[\\\\d]+)年',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+) ([\\\\d]+)時([\\\\d]+)分([\\\\d]+)',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+) ([\\\\d]+)時([\\\\d]+)分',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+) ([\\\\d]+)時',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+) ([\\\\d]+):([\\\\d]+):([\\\\d]+)',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+) ([\\\\d]+):([\\\\d]+)',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+).([\\\\d]+)',\n            '(('+ eraInitialPattern +')[\\\\d]+).([\\\\d]+)',\n            '(('+ eraInitialPattern +')[\\\\d]+)',\n        ];\n\n        for(let i in eraPatterns) {\n\n            let eraPattern = new RegExp(eraPatterns[i]);\n            let matches = date.match(eraPattern);\n\n            if(matches) {\n\n                let year = wafu.commonYear(matches[1]);\n                let matchesCount = matches.length;\n\n                if(matchesCount === 8) {\n\n                    return moment({\n                        year: year,\n                        month: parseInt(matches[3]) - 1,\n                        day: matches[4],\n                        hour: matches[5],\n                        minute: matches[6],\n                        second: matches[7]\n                    });\n\n                } else if(matchesCount === 7) {\n\n                    return moment({\n                        year: year,\n                        month: parseInt(matches[3]) - 1,\n                        day: matches[4],\n                        hour: matches[5],\n                        minute: matches[6],\n                        second: 0\n                    });\n\n                } else if(matchesCount === 6) {\n\n\n                    return moment({\n                        year: year,\n                        month: parseInt(matches[3]) - 1,\n                        day: matches[4],\n                        hour: matches[5],\n                        minute: 0,\n                        second: 0\n                    });\n\n                } else if(matchesCount === 5) {\n\n                    return moment({\n                        year: year,\n                        month: parseInt(matches[3]) - 1,\n                        day: matches[4],\n                        hour: 0,\n                        minute: 0,\n                        second: 0\n                    });\n\n                } else if(matchesCount === 4) {\n\n\n                    return moment({\n                        year: year,\n                        month: parseInt(matches[3]) - 1,\n                        day: 1,\n                        hour: 0,\n                        minute: 0,\n                        second: 0\n                    });\n\n                } else if(matchesCount === 3 || matchesCount === 2) {\n\n                    return moment({\n                        year: year,\n                        month: 0,\n                        day: 1,\n                        hour: 0,\n                        minute: 0,\n                        second: 0\n                    });\n\n                }\n\n            }\n\n        }\n\n        return null;\n\n    },\n\n\n    // Yen\n\n    yen(price, mode = 'comma') {\n\n        let yen = '';\n\n        switch(mode) {\n\n            case 'comma':\n                yen = wafu.numberFormat(price) +'円';\n                break;\n            case 'noComma':\n                yen = price +'円';\n                break;\n            case 'symbol':\n                yen = '￥'+ wafu.numberFormat(price);\n                break;\n            case 'symbolNoComma':\n                yen = '￥'+ price;\n                break;\n            case 'symbolCommaHyphen':\n                yen = '￥'+ wafu.numberFormat(price) +'-';\n                break;\n            case 'symbolNoCommaHyphen':\n                yen = '￥'+ price +'-';\n                break;\n\n        }\n\n        return yen;\n\n    },\n\n\n    // Consumption tax\n\n    consumptionTax(dt, amount, totalFlag = false) {\n\n        let percentage = 0.08;\n\n        if(dt.isBefore(moment({year: 1989, month: 3, day: 1}))) {   // month: 3 means April!\n\n            percentage = 0;\n\n        } else if(dt.isBefore(moment({year: 1997, month: 3, day: 1}))) {\n\n            percentage = 0.03;\n\n        } else if(dt.isBefore(moment({year: 2014, month: 3, day: 1}))) {\n\n            percentage = 0.05;\n\n        }\n\n        const tax = Math.floor(amount * percentage);\n\n        if(totalFlag) {\n\n            return amount + tax;\n\n        }\n\n        return tax;\n\n    },\n\n\n    // Zip\n\n    zip(zip, separator = '-') {\n\n        zip = wafu.singleByte(zip);\n\n        if(zip.length === 7) {\n\n            return zip.substr(0, 3) + separator + zip.substr(3, 4);\n\n        }\n\n        return '';\n\n    },\n\n    checkZip(zip, separator = '-') {\n\n        const pattern = new RegExp('^[0-9]{3}'+ separator +'[0-9]{4}$');\n        return (zip.search(pattern) !== -1);\n\n    },\n\n\n    // Single byte characters\n\n    singleByte(str, options = ['alphabet', 'numeric', 'space']) {\n\n        str = str.toString();\n        let patterns = [];\n        let patternCharacters = {\n            alphabet: 'Ａ-Ｚａ-ｚ',\n            numeric: '０-９',\n            space: '　',\n        };\n\n        for(let key in patternCharacters) {\n\n            if(options.indexOf(key) !== -1) {\n\n                let patternCharacter = patternCharacters[key];\n                patterns.push(patternCharacter);\n\n            }\n\n        }\n\n        if(patterns.length === 0) {\n\n            return str;\n\n        }\n\n        let pattern = new RegExp('['+ patterns.join('|') +']', 'g');\n        return str.replace(pattern, (match) => {\n\n            if(match === '　') {\n\n                return ' ';\n\n            }\n\n            return String.fromCharCode(match.charCodeAt(0) - 65248);\n\n        });\n\n    },\n\n\n    // Others\n    arrayGet(array, key, defaultValue) {\n\n        if(defaultValue === undefined) {\n\n            defaultValue = '';\n\n        }\n\n        if(array[key] === undefined) {\n\n            return defaultValue;\n\n        }\n\n        return array[key];\n\n    },\n\n    arrayValues(array) {\n\n        let values = [];\n\n        for(let key in array) {\n\n            values.push(array[key]);\n\n        }\n\n        return values;\n\n    },\n\n    getShortPrefecture(name) {\n\n        return name.replace(/(県|府|都)$/, '');\n\n    },\n\n    numberFormat(number) {\n\n        return number.toString().replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1,');\n\n    },\n};\n\nmodule.exports = wafu;\n\n//# sourceURL=webpack://wafu/./src/wafu.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/wafu.js");
/******/ })()
;
});